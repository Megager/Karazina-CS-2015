## Задания по ANTLR
Список лабораторных с баллами и сроками сдачи (окончательный):
- 1, 15 баллов, до 21 Октября
- 2, 20 баллов, до 22 Ноября
- 3, 25 баллов, до 01 Декабря*

(*) - передвинется где-то на 25е число, после согласования с ГН.

Задание можно сдать после срока, но не позже чем за неделю до экзамена, за 3/4 стоимости - на протяжениии двух недель после срока, за 2/3 стоимости после истечения двух дополнительных недель. Задание можно пересдать за 3/4 стоимости. Оптимальная форма сдачи задания - прислать по почте (впросьба  тексте письма указывать чья работа).

Задание можно делать вдвоем, при наличии убедительной причины - втроем, но по согласованию с преподавателем; в случае командной работы это надо явно указывать в сдаваемом проекте, т.е. например "делали Петр Петров и Иван Иванов". 

Если сданные работы будут черезмерно похожи, это будет считаться читерством и засчитываться такие работы не будут. Читерские работы можно один раз пересдать за 1/2 стоимости.

Множители мультипликативны (\*).

Альтернативно, можно сделать задание на автомат по курсу в целом, см. в конце.

#### Дополнительные материалы
[Курс по компиляторам на Coursera](https://class.coursera.org/compilers-004).

## Расписание занятий
- 30 Сентября
- 14 Октября - будет перенесена или на 7е, или на 21е 
- 28 Октября
- 11 Ноября
- 25 Ноября
- 9 Декабря
- 23 Декабря
 
## Формат ввода-вывода.
Все лабораторные предполагают, что вы получаете некоторое выражение на входе и получаете некоторый результат. Программма должна быть написана таким ообразом, что входная сттрока берется из файла [имя программы].in и результат записывается в [имя программы].out. 

В случае ошибки парсинга в файл выводится эта ошибка. 

В случае ошибки вычисления (т.е. например деления на 0 в первой лабораторной или вызов необъявленной переменной во второй), выводится пользовательское сообщение, характеризующее ошибку, и указывающее в каком месте (строка, столбец), произошла ошибка.

Для работы на автомат ситуация аналогичная, но несколько отличающаяся. Реализовать транслятор нужно как утилиту командной строки, т.е. на вход транслятор получает имя файла с программой на COOL и сгенерированные java-файлы записывает в тот же каталог что и исходный файл.  


## Первая лабораторная. Простой парсинг. (до 21 Октября, 15 баллов), ANTLR, Java

Сделать калькулятор, который понимает целые(положительные и отрицателные) числа, операции +, -, *, / и  ^ (возведение в степень), круглые скобки, взятие модуля, а также унарный минус (но без унарного плюса). Калькулятор должен не только разбирать правильность строки, но и считать получившееся выражение.  

Пробелы не учитываются. Деление целочисленное, деление на ноль выдает ошибку деления на 0. Неправильные строки выдают ошибку разбора. Приоритет операций обычный, т.е. сначала степень, потом умножение, потом сложение. Ввод из файла in.txt, вывод в файл out.txt (просьба выводить в виде [формула]=[ответ]).   

Пример результатов:
- 1+1=2
- |-3+2|=1
- -(-1)=1
- --1=1
- 1-=ParsingError
- 3/10 = 0
- (11 + -1)/(3/10)= ZeroDivisionError

О том, как работать с разобранными предложениями (в данном случае, как посчитать значения правильного выражения) я не рассказывал, но это не сложно. Можно посмотреть главу 4.2 (Building a Calculator Using a Visitor) в  The Definitive Introduction to ANTLR. 

## Вторая лабораторная. Полноценный парсинг, области видимости. (до 22 Ноября, 20 баллов), ANTLR, Java
Написать парсер для программ такого рода:
 - Программа состоит из объявлений переменных, присваиваний, циклов, ветвлений, операторов print
 - объявление переменных: `Int x=0, y=1, z=2` - переменные у нас только типа Int, начинаются обязательно с маленькой буквы,, могут содержать маленькие/большие буквы, цифры, символ _
 - присвоения вида: `x = 2+(y*5)` - правая сторона формируется так как в первой лаборатоной, плюс переменные.
 - циклы: while (условие) { операции } - условия это всевозможные сравнения переменныхх (<, <=, >, >=, ==, !=) со скобками, и связывающими операторами and, or и not, например `i<=j and not i<=k`
 - условия: if (условие) { операции } else { операции }, секции else может не быть.
 - оператор print: `print "Variable х equals" x ", hooray!"`. Это единственное место где допускаются строковые выражения. Выполнение операторов print формирует вывод программы. Каждый новый print выводится с новой строки. 
 - язык case-sensitive, т.е. `x` и `X`, а также `if` и `IF` это разные вещи.
 - переменные не могут называться как ключевые слова (while, if, else, ...)
 - идущие одно за дугим выражения разделяюются `;`, т.е. `Int i; i=1`
 - область видимости (scope) это операции между фигурными скобками, т.е. например
     
        `[1] if (1==1) { [2] ...while (1==1){[3]...} } else {[4]...}`.
Области видимости вкладываются друг в друга. В данном примере `[3]` вложено в `[2]` вложено в `[1]` и `[4]` вложено в `[1]`.
 - переменная может быть использована только после того, как была объявлена; в рамках одной облсти видимости переменная может быть объявлена только один раз, но может быть объявлена во вложенных областях видимости. В этом случае при использовании переменной, используется та, которая принадлежит наивысшей области видимости. Например
        `Int a=0; if (1==1){Int a=0; a = 10}; print a`
вернет `0`, а
        `Int a=0; if (1==1){ a = 10; Int a=0}; print a`
вернет `10`.

## Третья лабораторная. Оптимизация кода, . (до 1 Декабря*, 25 баллов), ANTLR, Java
(*) - передвинется где-то на 25е число, после согласования с ГН.

Реализовать для программ из второй лабораторной оптимизацию "Constant propagation" (подстановку констант). Суть данной оптимизации в то, чтоб заменить использование переменных явными значениями на этапе компиляции, там где такая замена возможна. Ваша программа должна на вход получать программу, и ее выход тоже программа, но оптимизированная. Например:

    Int x=0, y=1;
    Int z=x;
    while (z<10){
      z = z+y;
      print x;
      print y;
      x = x+z;
    }

превратится в

    Int x=0, y=1;
    Int z=0;
    while (z<10){
      z = z+1;
      print x;
      print 1;
      x = x+z;
    }


Поскольку и ввод, и вывод достаточно большие, то еще раз просьба ввод делать из файла in.txt, вывод в файл out.txt (оба файла рядом с файлом проекта).   

Подробно о том, как реализовывать constant propagation я расскажу на паре в среду 11.11.

Можно посмотреть про это [здесь](https://class.coursera.org/compilers-004/lecture/78). Это одна из лекций курса по компиляторам на Курсере, ссылку см. в начале. Вам может пригодиться также соседние лекции.

Также годится глава DataFlow Analysis [здесь](http://www.itu.dk/people/brabrand/UFPE/Data-Flow-Analysis/static.pdf), но это немного больше, чем вам надо.

P.S. Сам по себе constant propagation не очень полезный, и обычно нужен для последующей реализации Dead Code Elimination. Поэтому "полезный вариант" этого задания был бы реализовать оба эти метода. Но я этого задавать не буду, т.к. принцип там похожий, и для того чтоб разобраться в работе достаточно и одного из них.

#### Замечание
При подстановке констант важно сохранять пробелы, переносы строк, табуляцию и прочие не несущие смысловой нагрузки особенности исходной программы. Т.е.

    Int x=0;
        Int y=x; Int z=x;

должно превратиться в 

    Int x=0;
        Int y=0; Int z=0;

а не в

    Int x=0; Int y=0; Int z=0;

и не в

    Int x=0; 
    Int y=0; 
    Int z=0.

## Автомат (до 23 Декабря, 100 баллов), ANTLR, Java

Реализовать полноценный транслятор из языка COOL в Java (т.е. на входе программа на COOL, на выходе Java-код, выполняющий то же самое). Описание языка [здесь] (https://d396qusza40orc.cloudfront.net/compilers/resources/cool_manual.pdf).

Как и в случае обычных лабораторок, можно работать группами, но просьба анонсировать участие и состав до 1 Ноября. Работы от тех, кто этого не сделает, рассматриваться не будут. 


